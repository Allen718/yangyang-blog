(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{388:function(n,t,e){"use strict";e.r(t);var a=e(42),o=Object(a.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h2",{attrs:{id:"computed-watch-method区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#computed-watch-method区别"}},[n._v("#")]),n._v(" computed watch method区别")]),n._v(" "),e("ol",[e("li",[n._v("computed，计算属性，根据所依赖数据，动态显示新的计算结果，并且计算结果会缓存，\ncomputed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算，如果没有发生任何变化，那么调用当前的函数的时候会从缓存中读取。使用场景就是当一个属性受多个属性影响的时候。\n例子")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('new Vue({\ndata: {\nuser: {\nemail: "fangyinghang@qq.com",\nnickname: "方方",\nphone: "13812312312"\n}\n},\ncomputed: {\ndisplayName: {\nget() {\nconst user = this.user;\nreturn user.nickname || user.email || user.phone;\n},\nset(value) {\nconsole.log(value);\nthis.user.nickname = value;\n}\n}\n},\n// DRY don\'t repeat yourself\n// 不如用 computed 来计算 displayName\ntemplate: `\n<div>\n{{displayName}}\n<div>\n{{displayName}}\n<button @click="add">set</button>\n</div>\n</div>\n`,\nmethods: {\nadd() {\nconsole.log("add");\nthis.displayName = "圆圆";\n}\n}\n}).$mount("#app");\n\n')])])]),e("ol",[e("li",[n._v("watch 是指监听一个值的变化，然后执行一个函数，就像是一个data数据的监听回调，\n当依赖的 data 的数据变化，执行回调，在方法中会传入 newVal 和 oldVal。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。如果你需要在某个数据变化时做一些事情，使用watch。watch的语法很多，具体可以看文档（https://cn.vuejs.org/v2/api/#watch),但是记住一点，就是最好不要在里面使用箭头函数，因为所得到的this将不是你所期待得到的。\n基础例子")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('new Vue({\n  data: {\n    n: 0,\n    obj: {\n      a: "a"\n    }\n  },\n  template: `\n    <div>\n      <button @click="n += 1">n+1</button>\n      <button @click="obj.a += \'hi\'">obj.a + \'hi\'</button>\n      <button @click="obj = {a:\'a\'}">obj = 新对象</button>\n    </div>\n  `,\n  watch: {\n    n() {\n      console.log("n 变了");\n    },\n    obj:{\n      handler: function (val, oldVal) { \n      console.log("obj 变了")\n    },\n      deep: true // 该属性设定在任何被侦听的对象的 property 改变时都要执行 handler 的回调，不论其被嵌套多深,但实际就是对象的属性变了，存放这个对象的地址并没有变，对象也没变，默认值为false。\n    },\n    "obj.a":{\n      handler: function (val, oldVal) { \n      console.log("obj.a 变了")\n    },\n      immediate: true // 该属性设定该回调将会在侦听开始之后被立即调用\n    }\n  }}).$mount("#app");\n')])])]),e("p",[n._v('注意： 实例deep 控制是否要看这个对象里面的属性变化，immediate 控制是否在第一次渲染是执行这个函数。vm.$watch() 的用法和 watch 回调类似vm.$watch(\'data属性名\', fn, {deep: .., immediate: ..})vm.$watch("n", function(val, newVal){\nconsole.log("n 变了");\n},{deep: true, immediate: true})')])])}),[],!1,null,null,null);t.default=o.exports}}]);