(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{382:function(t,e,s){"use strict";s.r(e);var a=s(42),c=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h3",{attrs:{id:"开始第一个轮子，switch组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#开始第一个轮子，switch组件"}},[t._v("#")]),t._v(" 开始第一个轮子，switch组件")]),t._v(" "),s("ol",[s("li",[t._v("在components新建一个Switch-demo的组件，并为它添加路径，在main.ts的文件里面关于router添加路径与组件，并使它能够访问到。将关于vue router内容\n抽离为一个单独的ts文件。并在docs组件里使用routerview标签，给出相应的渲染区域。")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("import {createRouter, createWebHashHistory} from \"vue-router\";\nimport home from \"./views/home.vue\";\nimport docs from \"./views/docs.vue\";\nimport SwitchDemo from \"./components/Switch-demo.vue\";\nconst history = createWebHashHistory()\n  export const router = createRouter({\n  history: history,\n  routes: [{ path: '/', component: home },\n    { path: '/docs', component: docs ,children:[\n        {path:'',component:DocsDemo},//默认显示页面\n        {path:'switch',component:SwitchDemo},//swith页面\n       \n")])])]),s("ol",{attrs:{start:"2"}},[s("li",[t._v("在src目录下新建一个lib 目录，创建Switch.vue.switch表示在两种状态间切换时用到的开关选择器。api设计当value为'true'或是true时表示开，其余值都为关。")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('<Switch value="true" /> value 为字符串 "true"\n<Switch value="false" /> value 为字符串 "false"\n<Switch :value="  true  " /> value 为布尔值 true\n<Switch :value="  false  " /> value 为布尔值 false\n')])])]),s("p",[t._v("3.开始写代码，先写html再写css 最后再写js ,参考其他网站的switch ,基本上都是一个一个button按钮，里面再有一个小圆圈，为一个span标签，关于html和css都是可以参考其他网站样式的\n4. houver之后右滚，可以修改相对定位，hover之后修改left的值，采用计算"),s("code",[t._v("left:calc(100% -#{$h} -2px)")]),t._v(",添加上动画使用css transition.\n5. switch 正常应该是点击以后右滚，开始实现此功能，首先，需要一个数据，点击后修改数据，来切换。在switch组件里面定义一个数据，当点击修改数据，通过给组件添加类的方式修改样式。\n代码实现,")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('<button @click="toggle" :class="{checked}"> <span></span> </button>\n setup(){\n    const checked = ref(false)\n    const toggle = ()=>{\n      checked.value = !checked.value\n    }\n    return {checked, toggle}\n  }\n')])])]),s("p",[t._v("一个switch的功能就实现了，但请注意一个问题，用户使用了这个组件，用户就不能修改这个默认的状态，假设我们设置默认为关闭的状态但是使用者想要默认开启状态做不到，并且添加功能也不现实。")]),t._v(" "),s("ol",{attrs:{start:"6"}},[s("li",[t._v("上面分析，switch组件存在着问题，switch 组件控制开关的数据应该由外部传入，并不应该是内部数据，所以需要使用到vue3的props,在Switch-demo组件里传入数据，switch组件接受数据然后做出反应")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('<Switch :value="y" @input="y=$event" />\n setup(){\n     const y=ref(false)\n    return{y}\n  }\n  switch组件\n   <button @click="toggle" :class="{checked:value}"> <span></span> </button>\n    setup(props, context){\n    const toggle = ()=>{\n      context.emit(\'input\', !props.value)//与vue2有区别this.$emit() \n    }\n')])])]),s("ol",{attrs:{start:"7"}},[s("li",[t._v("vue3的v-model，数据双向绑定，vue3已经取消.sync修饰符，如果想要使用数据双向绑定首先事件触发的事件名固定格式"),s("code",[t._v("context.emit('update:value', !props.value)")]),t._v(",然后监听"),s("code",[t._v('<Switch v-model:value="y"/>')])]),t._v(" "),s("li",[t._v("整理代码，组件基本完成")])])])}),[],!1,null,null,null);e.default=c.exports}}]);