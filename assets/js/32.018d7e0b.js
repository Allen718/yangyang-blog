(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{351:function(t,a,e){"use strict";e.r(a);var s=e(42),n=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"layout布局"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#layout布局"}},[t._v("#")]),t._v(" layout布局")]),t._v(" "),e("h4",{attrs:{id:"需求分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#需求分析"}},[t._v("#")]),t._v(" 需求分析")]),t._v(" "),e("p",[t._v("1.一般网站的布局有以下几种：上中下（导航栏 内容栏，底部栏）也有上 中（左边侧边栏，右边内容栏）下（底部栏），或是左边内容栏，右边是侧边栏。\n2.分析代码 ,借鉴其他组件库的实现过程")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("<layout>\n<header></header>\n<layout>\n<sider></sider>\n<content></content>\n</layout>\n<footer></footer>\n</layout>\n")])])]),e("h3",{attrs:{id:"开始写代码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#开始写代码"}},[t._v("#")]),t._v(" 开始写代码")]),t._v(" "),e("ol",[e("li",[t._v("根据标签知道应该有个layout sider content footer header这几个组件，创建这几个组件，全局声明这几个组件，在index.html里面测试代码")]),t._v(" "),e("li",[t._v("使用flex布局，简单的布局方式都能做到，只有一个冲突需要解决，有时layout的flex-diretion需要是column,然后有时候就是row，当里面有侧边栏的时候就将布局改为row.具体实现思路检测layout组件的子组件是否含有侧边栏组件")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v(" mounted() {\n      console.log(this.$children)\n      this.$children.forEach(vm=>{\n        if(vm.$options.name==='Sider'){\n            this.layoutClass.hasSider=true\n        }\n              \n")])])]),e("p",[t._v("一般顺序是先创建父组件，然后创建子组件，将子组件挂载在父组件上，最后再将父组件渲染在页面，所以如果使用created不能找到子组件的。所以要合理使用钩子。不要使用原生的js来给layout添加类。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("data(){\n      return{\n       layoutClass:{\n         hasSider:false\n       }\n      }\n    },\n")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);