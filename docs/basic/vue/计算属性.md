## computed watch method区别
1. computed，计算属性，根据所依赖数据，动态显示新的计算结果，并且计算结果会缓存，
computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算，如果没有发生任何变化，那么调用当前的函数的时候会从缓存中读取。使用场景就是当一个属性受多个属性影响的时候。
例子

```
new Vue({
data: {
user: {
email: "fangyinghang@qq.com",
nickname: "方方",
phone: "13812312312"
}
},
computed: {
displayName: {
get() {
const user = this.user;
return user.nickname || user.email || user.phone;
},
set(value) {
console.log(value);
this.user.nickname = value;
}
}
},
// DRY don't repeat yourself
// 不如用 computed 来计算 displayName
template: `
<div>
{{displayName}}
<div>
{{displayName}}
<button @click="add">set</button>
</div>
</div>
`,
methods: {
add() {
console.log("add");
this.displayName = "圆圆";
}
}
}).$mount("#app");

```
1. watch 是指监听一个值的变化，然后执行一个函数，就像是一个data数据的监听回调，
当依赖的 data 的数据变化，执行回调，在方法中会传入 newVal 和 oldVal。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。如果你需要在某个数据变化时做一些事情，使用watch。watch的语法很多，具体可以看文档（https://cn.vuejs.org/v2/api/#watch),但是记住一点，就是最好不要在里面使用箭头函数，因为所得到的this将不是你所期待得到的。
基础例子
```
new Vue({
  data: {
    n: 0,
    obj: {
      a: "a"
    }
  },
  template: `
    <div>
      <button @click="n += 1">n+1</button>
      <button @click="obj.a += 'hi'">obj.a + 'hi'</button>
      <button @click="obj = {a:'a'}">obj = 新对象</button>
    </div>
  `,
  watch: {
    n() {
      console.log("n 变了");
    },
    obj:{
      handler: function (val, oldVal) { 
      console.log("obj 变了")
    },
      deep: true // 该属性设定在任何被侦听的对象的 property 改变时都要执行 handler 的回调，不论其被嵌套多深,但实际就是对象的属性变了，存放这个对象的地址并没有变，对象也没变，默认值为false。
    },
    "obj.a":{
      handler: function (val, oldVal) { 
      console.log("obj.a 变了")
    },
      immediate: true // 该属性设定该回调将会在侦听开始之后被立即调用
    }
  }}).$mount("#app");
  ```
注意： 实例deep 控制是否要看这个对象里面的属性变化，immediate 控制是否在第一次渲染是执行这个函数。vm.$watch() 的用法和 watch 回调类似vm.$watch('data属性名', fn, {deep: .., immediate: ..})vm.$watch("n", function(val, newVal){
      console.log("n 变了");
},{deep: true, immediate: true})


