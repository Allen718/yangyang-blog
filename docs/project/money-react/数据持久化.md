### 数据持久化
数据持久化,就是将我们的数据保存下来，适当的时机保存，适当的时机去拿。不要每次刷新页面以后我的新增标签就消失了
1. 将新增标签这个api封装进入useTag.tsx文件里面。
```
   const addTag = () => {
       const tagName = window.prompt('新标签的名称为');
    if (tagName !== null && tagName !== '') {
      setTags([...tags, {id: createId(), name: tagName}]);
    }
  };
  return {tags, addTag, setTags, findTag, updateTag, findTagIndex, deleteTag};
};
```
2.使用useEffect函数，作为钩子函数去保存和获取tags
```
const [tags, setTags] = useState<{ id: number; name: string }[]>([]);
 useEffect(() => {
   let localTags = JSON.parse(window.localStorage.getItem('tags') || '[]');
    if (localTags.length === 0) {
      localTags = [
        {id: createId(), name: '衣'},
        {id: createId(), name: '食'},
        {id: createId(), name: '住'},
        {id: createId(), name: '行'},
      ];
    }
    setTags(localTags);

  }, []); // 组件挂载时执行
  ```
  3.我们使用useEffect对tags这个数据进行监听，当它变化时我们就保存tags,但是会出现bug, 当tags从无到有的这个过程的时候，我们并不希望保存，因为保存的就是一个空数组，违背本意，所以需要处理一下，从无到有的这个过程并不监听。
  ```
  import {useEffect, useRef} from 'react';
  export const useUpdate = (fn: () => void, deps: any[]) => {
  const count = useRef(0);
  useEffect(() => {
    count.current += 1;
  });
  useEffect(() => {
    if (count.current > 1) {
      fn();
    }
  }, deps); // 不可变数据
};
  useUpdate(() => {
    window.localStorage.setItem('tags', JSON.stringify(tags));
  }, [tags]);
  ```
  4. 修改id生成出现的问题
  ```
 let id = parseInt(window.localStorage.getItem('idMax') || '0');
const createId = ():number => {
  id += 1;
  window.localStorage.setItem('idMax', JSON.stringify(id))
  return id;
};
  useEffect(() => {
    let localTags = JSON.parse(window.localStorage.getItem('tags') || '[]');
    if (localTags.length === 0) {
      localTags = [
        {id: createId(), name: '衣'},
        {id: createId(), name: '食'},
        {id: createId(), name: '住'},
        {id: createId(), name: '行'},
      ];
    }
    setTags(localTags);
  ```
  5. 记账页面的记账数据的持久化
  新建一个useRecord.tsx文件夹，用来管理记账页面的关于记一次账的数据
 ```
import {useEffect, useState} from 'react';
import {useUpdate} from './useUpdate';
type RecordItem = {
  tagIds: number[]
  note: string
  category: '+' | '-'
  amount: number
  createdAt: string // ISO 8601
}
type newRecordItem = Omit<RecordItem, createdAt>
export const useRecords = () => {
  const [records, setRecords] = useState<RecordItem[]>([]);
  useEffect(() => {
    setRecords(JSON.parse(window.localStorage.getItem('records') || '[]'));
  }, []);
  useUpdate(() => {
    window.localStorage.setItem('records', JSON.stringify(records));
  }, [records]);
  const addRecord = (newRecord: newRecordItem) => {
    const record = {...newRecord, createdAt: (new Date()).toISOString()};
    setRecords([...records, record]);
  };
  return {records, addRecord};
};
应用
const defaultFormData = {
  tagIds: [] as number[],
  note: '',
  category: '-' as Category,
  amount: 0
};
 const [selected, setSelected] = useState(defaultFormData);
  const {records, addRecord} = useRecords();
  const onChange = (obj: Partial) => {
    setSelected({...selected, ...obj});
  };
  const submit = () => {
    addRecord(selected);
    alert('保存成功');
    setSelected(defaultFormData);
  };
  6. 发现一个bug，在记账页面没法输入点的bug，原来是因为，我们在收集这个record的时候，声明的amount的数据类型是number,当数据变化的时候立马收集会存在问题，我们需要在数字NumberPad.tsx做一些变化·
  ``` 
  const [output, _setOutput] = useState(props.value.toString());
  const setOutput = (output: string) => {
    let value;
    let newOutput: string;
    if (output.length > 16) {
       newOutput = output.slice(0, 16);
    } else if (output.length === 0) {
         newOutput = '0';
    } else {
       newOutput = output;
    }
       _setOutput(newOutput);
    props.onChange(parseFloat(newOutput));
  };
  const onClickButtonWrapper = (e: React.MouseEvent) => {
    const text = (e.target as HTMLButtonElement).textContent;
  ```

