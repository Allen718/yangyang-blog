## 标签编辑页面的制作
1.首先根据设计出图实现标签编辑页面的ui，大概分为三部分,一个顶部的导航栏，一个标签列表，然后一个删除按钮，顶部导航栏是一个图标，一个文字，使用flex布局，左边一个icon,然后中间文字，为了布局，在右边添加一个icon占位但是并不要出现一个icon图片。为了实现这个功能需要对引入icon的组件做一下修改
```
type Props = {
   name?: string
}
const Icon = (props: Props) => {
  return (
    <svg className="icon">
      {props.name && <use xlinkHref={'#' + props.name}/>}
    </svg>
  );
};
```
由于button按钮不仅在这个组件里使用，在标签页面也会使用到button组件，一个应用里面所有的按钮应该是同一规格，所以将button做成一个单独的组件，供使用
```
import styled from 'styled-components';
const Button = styled.button`
  font-size: 18px; border: none; padding: 8px 12px;
  background: #f60; border-radius: 4px;
  color: white;
`;
export {Button}
```
2. 创建单独的Input组件，由于input组件也是会多次用到，所以将input组件封装一下，避免重复。优化代码
```
import React from 'react';
import styled from 'styled-components';
const Label = styled.label`
    display:flex;
    align-items: center;
    > span { margin-right: 16px; white-space: nowrap; }
    > input {
      display:block;
      width: 100%;
      height: 72px;
      background: none;
      border: none;
    }
`;
type Props = {
  label: string;
} & React.InputHTMLAttributes<HTMLInputElement>;//声明类型，新知识，多看
const Input: React.FC<Props> = (props) => {
  const {label, children, ...rest} = props;
  return (
    <Label>
      <span>{props.label}</span>
      <input {...rest} />
    </Label>
  );
};

export {Input};
使用例子
 <Input label="备注" type="text" value={note} onChange={onChange}/>
 ```
  引入这些组件在EditTag里面以后，然后整合，书写css样式，完成标签编辑页面的UI.
  
3. 完成标签编辑页面的修改标签的功能，修改标签这个功能应该放在useTag里面，然后导出使用
 ```
  const findTagIndex = (id: number) => {
    let result = -1;
    for (let i = 0; i < tags.length; i++) {
      if (tags[i].id === id) {
        result = i;
        break;
      }
    }
    return result;
  };
  const updateTag = (id: number, obj: { name: string }) => {
      const index = findTagIndex(id);
    // 深拷贝 tags 得到 tagsClone
    const tagsClone = JSON.parse(JSON.stringify(tags));
    // 把 tagsClone 的第 index 删掉，换成 {id:id, name: obj.name}
    tagsClone.splice(index, 1, {id: id, name: obj.name});
    setTags(tagsClone);
  };
  return {tags, setTags, findTag, updateTag, findTagIndex};
};
在EditeTag.tsx引用
 const {findTag, updateTag} = useTags();
  let {id: idString} = useParams<Params>();
  const tag = findTag(parseInt(idString));
     <Input label="标签名" type="text" placeholder="标签名"
               value={tag.name}
               onChange={(e) => {
                 updateTag(tag.id, {name: e.target.value});
               }}
        />
   ```
   4. 完成标签编辑页面的删除功能，思路基本和标签修改的思路差不多
   ```
    const deleteTag = (id: number) => {
    // 获取你要删的 tag 的下标
    const index = findTagIndex(id);
    // 深拷贝 tags 得到 tagsClone
    const tagsClone = JSON.parse(JSON.stringify(tags));
    // 把 tagsClone 的第 index 删掉
    tagsClone.splice(index, 1);
    setTags(tagsClone);
  };
  return {tags, setTags, findTag, updateTag, findTagIndex, deleteTag};
};
```
应用
 <Button onClick={() => {
          deleteTag(tag.id);
        }}>删除标签</Button>
  删除了标签这个页面就不存在了，就会出现404，处理一下这个
  const content=()=>{
    return(<div>
      <Input label='标签名'
             type="text"
             value={tag.name}
             onChange={(e)=>{
               updateTag(tag.id,{name:e.target.value})
             }}/>
      <Center>
        <Button onClick={()=>{
          deleteTag(tag.id)
        }}>删除标签</Button>
      </Center></div>)}
      
       {tag?content():<Center><div> 标签名不存在</div></Center>}
   ```
    5. 支持回退，期望当点击向左的icon图标的时候页面回退，首先icon图标不支持点击，其次回退功能要实现使用那个api
   ```
    Icon.tsx文件
    type Props = {
     name?: string
        }
  } & React.SVGAttributes<SVGElement>
    const Icon = (props: Props) => {
  const {name, children, className, ...rest} = props//如果不把className单独提出来，那么
  如果外部传了一个className，
  就会把原本的的className覆盖，如果既不想内部的className被覆盖又想要外部的className
 使用外部工具'npm install classnames,npm install @types/classnames'
  import cs from 'classnames';
  return (
    <svg className="icon">
    <svg className={cs('icon', className)} {...rest}>
      {props.name && <use xlinkHref={'#' + props.name}/>}
    </svg>
  );
   ```
然后关于回退，可以使用原生的`window.histoty.back()`,使用history路由的时候，进行回退是不刷新页面的，可以通过network查看，因为页面刷新就意味着新的请求，也可以在入口文件打log的方法验证。本应用是react项目，回退也使用react提供的回退api来实现回退。
   ```
import {useParams, useHistory} from 'react-router-dom';
 const history = useHistory()
  const onClickBack = ()=>{
    history.goBack()
  }
  ```
    


    
        
        