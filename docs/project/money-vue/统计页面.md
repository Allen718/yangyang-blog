### 统计页面的制作
1.修改Types.vue,让统计页面也是可以使用这个组件，由于统计页面里面这组件当选中的时候不仅下面有黑色小横条，并且选框的颜色需要改变，但是在记账页面又不需要颜色改变，我们可以对这个组件进行二次封装，在使用Types.vue组件的statistics.vue组价里面给Type.vue组件再加类名来修改样式，为了能够给Types.vue组件里面的元素加上样式我们需要用到vue的deep属性

```
 .x::v-deep .li {
    background: white;
    &.selected {
      background: #C4C4C4;
      &::after {
        display: none;
      }
    }
  }
```
由于可能Types.vue组件里面的li元素可能比较多并且复杂的话，最好是传个前缀进去，然后定位会更加准确。
 ```
<ul class="types">
      <li :class="{[classPrefix+'-item']: classPrefix, selected: value==='-'}"
          @click="selectType('-')">支出
      </li>
      <li :class="{[classPrefix+'-item']: classPrefix, selected: value==='+'}"
          @click="selectType('+')">收入
      </li>
    </ul>
      
    @Prop(String) readonly value!: string;
    @Prop(String) classPrefix?: string;
statistics.vue组件这样使用
  <Types class-prefix="type" :data-source="typeList" :value.sync="type"/>
::v-deep .type-tabs-item {
    background: white;
    &.selected {
      background: #C4C4C4;
      &::after {
        display: none;
      }
    }
  }
   
```
2. 由于设计稿中出现了一个按天 按周 按月的一个导航条，它的样式和上面的支出与收入的类型基本上一样，考虑进一步修改Types.vue组件，让他变得更加的通用，改动太多，直接重建一个叫做Tabs.vue组件，然后将Types.vue里面的有用的代码抄过来，然后开始编辑这个Tabs.vue变得更加通用，具体看文件Tabs.vue，给一个`@Prop({required: true, type: Array})
    dataSource!: DataSourceItem[];`,然后将所有用到Types.vue的组件的地方全都修改成引入Tabs.vue,由于dataSource里面的 `typeList = [
      {text: '支出', value: '-'},
      {text: '收入', value: '+'},
    ];`会多次使用，根据我与重复不共戴天原理，所以直接将其单独提出里更好，再src目录下新建一个叫做constant（常量）目录，新建一个叫做typeList.ts文件
    
```
    export default Object.freeze([
  {text: '支出', value: '-'},
  {text: '收入', value: '+'},
]);//freeze的意思是只能读不允许修改
   
 ```
3. 引用Tabs.vue时候由于高度不同，需要在在引用这个组件里面传前缀来通过css修改这个高度，有时候会失败，这是因为选择器的优先级原因，要么提高引用组件时的css权重，或是降低组件自身在写css的样式的权重。在提供一条思路，就是选择用js来控制这个高度，

```
 <ul class="tabs" :class="{[classPrefix+'-tabs']: classPrefix}" :style="{height:height}">
    <li v-for="item in dataSource" :key="item.value" class="tabs-item"
        :class="liClass(item)" @click="select(item)">{{item.text}}
    </li>
  </ul>
@Prop({type: String, default: '64px'})
    height!: string;
    
 ```
 4. 书写statistics.vue的页面内容，完成列表的内容，首先我们可以拿到recordList,这是一个数组，他是一个
```
 RecordItem = {
  tags: string[]
  notes: string
  type: string
  amount: number // 数据类型 object | string
  createdAt?: Date  // 类 / 构造函数
}
```
由于通过this.$store来取这个recordList的时候，它的类型会变成一个any,所以当我们拿到这个recordList的时候，我们需要自己断言一下这是个recordItem类型，
```
get recordList() {
      return (this.$store.state as RootState).recordList;
    }
  ```
但是当我们从localStroge取出这个recordList的时候，JSON.parse并不识别Date类型，所以我们需要将createAt的类型修改一下，变成一个string，这就使得将有createAt的地方修改一下， `record2.createdAt = new Date().toISOString()`;

  4. 拿到recordList以后，我们需要将这个数组做成我们需要的结构类似于下面这种,然后就开始写css样式
```
   <li v-for="(group,index) in result" :key="index">
        <h3 class="title">{{group.title}}</h3>
        <ol>
          <li v-for="item in group.items" :key="item.id"
              class="record"
          >
            <span>{{tagString(item.tags)}}</span>
            <span class="notes">{{item.notes}}</span>
            <span>￥{{item.amount}} </span>
          </li>
        </ol>
      </li>
  get result() {
      const {recordList} = this;
      type HashTableValue = { title: string, items: RecordList }
      const hashTable: { [key: string]: HashTableValue } = {};
      for (let i = 0; i < recordList.length; i++) {
        const [date, time] = recordList[i].createdAt!.split('T');
        hashTable[date] = hashTable[date] || {title: date, items: []};
        hashTable[date].items.push(recordList[i]);
      }
      return hashTable;
    }
```
5. 关于时间的概念，知识总结。
```
    let day=new Date()//得到一个事件
    console.log(day)//Wed Aug 12 2020 16:22:13 GMT+0800 (中国标准时间)
    day.toISOString()//"2020-08-12T08:22:13.036Z"
    Date.parse("2020-08-12T08:22:13.036Z")//1597220533036
    new Date(1597220533036)//Wed Aug 12 2020 16:22:13 GMT+0800 (中国标准时间)
    new Date(1597220533036).getHours()//16
    ```
    使用dayjs,采用crm学习法。首先进入官网然后安装，开始使用,以后还有什么需要学习的就自己去搜索
    ```
      import dayjs from 'dayjs';
       beautify(string: string) {
      const now = new Date();//也可以是const now=dayjs()
      if (dayjs(string).isSame(now, 'day')) {
        return '今天';
      } else if (dayjs(string).isSame((now.valueOf() - 86400 * 1000), 'day')) {
        return '昨天';
      } else if (dayjs(string).isSame(dayjs().subtract(2, 'day'), 'day')) {
        return '前天';
      } else if (dayjs(string).isSame(now, 'year')) {
        return dayjs(string).format('M月D日');
      } else {
        return dayjs(string).format('yyyy年MM月DD日');
      }
    }
```
 6. 为了让在统计页面显示的数据是有序的，今天，昨天，前天，与更早的时间，我么需要在得到hashTable之前就将这个recordList排好序
```
     function clone<T>(data: T): T{
    return JSON.parse(JSON.stringify(data))
       }//上述中的三个T分别代表着 第一个声明一个T类型，第二个data的类型为T,第三个为返回值类型为T
  
 export default clone
   const newList = clone(recordList).sort((a, b) =>  dayjs(b.createdAt).valueOf() - dayjs(a.createdAt).valueOf())
```
7. 然后开始改造hashTable，使他变成一个数组
  ```
     const hashTable: HashTable = [{title: dayjs(newList[0].createdAt).format('YYYY-MM-DD'), items: [newList[0]]}];
      for (let i = 1; i < newList.length; i++) {
        const current = newList[i];
        const last = hashTable[hashTable.length - 1];
        if (dayjs(current.createdAt).isSame(dayjs(last.title), 'day')) {
          last.items.push(current);
        } else {
          hashTable.push({title: dayjs(current.createdAt).format('YYYY-MM-DD'), items: [current]});
        }
        上面样式也得改动
         <ol>
      <li v-for="(group,index) in groupList" :key="index">
        <h3 class="title">
          {{beautify(group.title)}}<span>{{group.total}}</span>
        </h3>
        <ol>
          <li v-for="item in group.items" :key="item.id"
              class="record">
            <span>{{tagString(item.tags)}}</span>
            <span class="notes">{{item.notes}}</span>
            <span>￥{{item.amount}} </span>
          </li>
        </ol>
      </li>
     </ol>                                                                                              
   ```
   8. 页面最好是每天的花费再做一个统计总额度,
```
   type HashTable={
   title: string;
   total?: number;
   items: RecordList;
    }[ ]//声明类型
     hashTable.map(group => {
        group.total = group.items.reduce((sum, item) => {return sum + item.amount;}, 0);
      });
```
  
    